#pragma config(Sensor, in1,    colorSensor,    sensorReflection)
#pragma config(Sensor, in2,    colorSensorBackup, sensorNone)
#pragma config(Sensor, dgtl10, debugLED0,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, debugLED1,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, debugLED2,      sensorLEDtoVCC)
#pragma config(Motor,  port2,           servoOfEmbarkment, tmotorServoContinuousRotation, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           door1,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           door2,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           launcherMotor, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*======================================================================================================================*/
/*=========================================================ENTRY========================================================*/
/*======================================================================================================================*/

//Function Definitions
void Init(); void MainFunc(); void ReleaseNextItem(); void DetectMarble(); void SortMarble();

enum machineStatus{busy, ready, confused, terminated}; enum machineStatus status; //System status enumerations declared
enum marbleType{black, white, trans, other}; enum marbleType marble; //Marble type enumerations declared

struct systemStruct
{
	short servoInterval; //Ticks for servo
	short photoValue; //Value of photonsensor

	short servoOfEmbarkmentPos[2]; //Positions for the servo [L, C, R]
	short photoThresholds[3][2]; //Two dimensional array for sensor thresholds of each marble
}

struct systemStruct system;

task main() { Init(); } //The entery point to the program dum-dum! Calls Init function

//The following tasks will always check values and assign booleans against the checks
task PhotoSensor() { while(true) { system.photoValue = SensorValue[in1]; } }

task debug() //Debug tasks enables led's to help relay status to the developers
{
	while(true) //Always and forever...
	{
		turnLEDOff(debugLED0); turnLEDOff(debugLED1); turnLEDOff(debugLED2); //Disable all LED's
		switch(status) { case busy: turnLEDOn(debugLED1); break; case ready: turnLEDOn(debugLED0); break; case confused: turnLEDOn(debugLED2); break; default: break; } //Enable LED's Conditionally
		wait(0.1); //Wait before checking again to save resources
	}
}

void Init() //Initailize the program
{
	status = terminated; //System status is terminated
	startTask(debug); //Start debug task

	//Set struct variables
	system.photoValue = 0;
	system.servoInterval = 127;

	//Set struct arrays
	system.servoOfEmbarkmentPos[0] = -system.servoInterval;
	system.servoOfEmbarkmentPos[1] = system.servoInterval;
	system.photoThresholds[0][0] = 70; system.photoThresholds[0][1] = 110;
	system.photoThresholds[1][0] = 0; system.photoThresholds[1][1] = 70;
	system.photoThresholds[2][0] = 200; system.photoThresholds[2][1] = 500;

	status = ready; //Machine is now ready
	MainFunc(); //Enter the main function
}

void MainFunc() //This is parrant function in struct
{
	startTask(PhotoSensor); //Start checking for photo values

	while(true) //Always and forever...
	{
		ReleaseNextItem();
		DetectMarble();
		SortMarble();
	}
}

void ReleaseNextItem() //Release the next marble
{
	setMotor(port5, -20);
	wait(0.5);
	stopMotor(port5);

	wait(2);

	for(byte indx = 0; indx < 2; indx++)
	{
		setMotor(port2, system.servoOfEmbarkmentPos[indx]); //Move servo to release positions
		wait(0.5); //Wait for the servo to get to it's position
	}
}

void DetectMarble()
{
	if(system.photoValue > system.photoThresholds[0][0] && system.photoValue < system.photoThresholds[0][1])
	{
		marble = black;
		status = busy;
	}
	else
	{
		if(system.photoValue > system.photoThresholds[1][0] && system.photoValue < system.photoThresholds[1][1])
		{
			marble = white;
			status = busy;
		}
		else
		{
			if(system.photoValue > system.photoThresholds[2][0] && system.photoValue < system.photoThresholds[2][1])
			{
				marble = trans;
				status = busy;
			}
			else
			{
				marble = other;
				status = confused;
			}
		}
	}
}

void SortMarble()
{
	switch(marble)
	{
		case black:
			setMotor(port3, 0);
			setMotor(port4, 127);
			break;
			
		case white:
			setMotor(port3, 127);
			setMotor(port4, 0);
			break;
			
		default:
			setMotor(port3, 0);
			setMotor(port4, 0);
			break;
	}
}
